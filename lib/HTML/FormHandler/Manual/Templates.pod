package HTML::FormHandler::Manual::Templates;
# ABSTRACT: using templates

=head1 SYNOPSIS

Documentation on templates to use with L<HTML::FormHandler>

=head1 Using templates

There is a FormHandler Template Toolkit rendering role at
L<HTML::FormHandler::Render::WithTT>, with a testcase in t/render_withtt.t.
Normally, however, it probably won't make much sense to use both a
TT parser in FormHandler, and a separate one for the "complete" templates,
so it seems like the TT renderer would mainly be useful for tests,
or as an example of how to do TT rendering with HFH.

A common way of using FormHandler with templates is to use the template
for layout, specifying the divs and spans and wrappers, and then
use the form object to render just the input fields.

    in your form:
    has '+widget_wrapper' => ( default => 'None' );

    <form id="myform" action="/myaction" method="post">
        <div class="span9">
            <span class="label">My Foo</span>
            [% form.field('foo').render %]
        </div>
        <div class="span7">[% form.field('bar').render %]</div>
        [% form.field('save').render %]
    </form>

However, you can also render entirely with templates.
There are lots of different ways to set up templates. There are sample
templates installed in FormHandler's 'share' directory. These templates
are now organized more-or-less similarly to the widget roles, with 'field',
'wrapper', and 'form' directories, but many other organizations are possible.

There is also a template which combines the template rendering code into
one file, 'share/templates/form/form_in_one.tt'. You can copy this template
into your own TT directories, perhaps as form.tt, and then specify it in
as the template for your Catalyst actions. You can customize it by adding
additional widget and widget_wrapper block, and then setting those in your
field definitions.

Note that widget names usually are camelcased, like the Moose roles that
implement them in the Widget directory. You probably want to use the
non-camelcased widget/wrapper names in your TT templates, though (using
the C<< $field->uwidget >> and C<< $field->twidget >> convenience methods).
('MySpecialWidget' is the equivalent of 'my_special_widget')

   has_field 'my_field' => ( widget => 'MySpecialWidget' );
   has_field 'another_field' => ( widget => 'YetAnotherWidget' );

And include them in a generic template:

   [% PROCESS widget/form_start.tt %]

   [% FOREACH f IN form.sorted_fields %]
      [% PROCESS widget/${f.twidget} %]
   [% END %]

   [% PROCESS widget/form_end.tt %]

Note that 'twidget' will provide a de-camelcased widget name plus '.tt'.
If you want just a de-camelcased widget name, use f.uwidget. See the
templates supplied in share/templates.

=head1 Field attributes

If you want to use the 'process_attrs' function to pull in HTML attributes
for the input elements, wrappers, and labels, you would need to pass that
function into your TT setup. See L<HTML::FormHandler::Render::WithTT> for an
example:

    use HTML::FormHandler::Render::Util ('process_attrs');
    $c->stash( process_attrs => &process_attrs ); # or add to TT vars in your view

    label [% process_attrs(f.label_attributes) %]for="[% f.html_name %]">
    [% f.label %]: </label>
    <input type="[% f.input_type %]" name="[% f.html_name %]" id="[% f.id %]"
    [% process_attrs(f.attributes) %] value="[% f.fif %]">

=head1 Sample templates

Note that the following templates assume that the field is in a TT variable "f",
as though they were processed in the above loop. Otherwise the individual
fields could be preceded by something like:

  [% f = form.field('title') %]

=head2 Text input field with error class on div & error messages

   <div class="[% f.css_class %] [% IF f.has_errors %]error_fld[% END %]">
   [% IF f.has_errors %]
     [% FOR error IN f.errors %]
       <p><span class="error" id="error">[% error %] </span></p>
     [% END %]
   [% END %]
   <label class="label" for="[% f.id %]">[% f.label %]</label>
   <input type="text" name="[% f.html_name %]" id="[% f.id %]" value="[% f.fif %]">
   </div>

Simple text field;

   [% f = form.field('text_field') %]
   <div><label class="label" for="[% f.id %]">[% f.label %]: </label>
   <input type="text" name="[% f.html_name %]" id="[% f.id %]" value="[% f.fif %]" /> </div>


=head2 Select field

Single select:

   <label class="label" for="[% f.id %]">[% f.label %]</label>
   <select name="[% f.html_name %]" id="[% f.id %]>
     [% FOR option IN f.options %]
       <option value="[% option.value %]"
       [% IF option.value == f.fif %]
          selected="selected"
       [% END %]>
       [% option.label %]</option>
     [% END %]
   </select>

Multiple select:

   <label class="label" for="[% f.id %]">[% f.label %]</label>
   <select name="[% f.html_name %]" id="[% f.id %]
             multiple="multiple" size="[% f.size %]">
     [% FOR option IN f.options %]
       <option value="[% option.value %]"
       [% FOREACH optval IN f.value %]
          [% IF optval == option.value %]
             selected="selected"
          [% END %]
       [% END %]>
       [% option.label %]</option>
     [% END %]
   </select>

Warning: TT has problems with single element arrays. If you are likely
to have a single element in a select list, you might want to use the
rendering method instead or add an extra "choose" row. (If you come up
with a good solution, please submit a doc patch.)

=head2 Checkbox

   <div><label class="label" for="[% f.id %]">[% f.label %]: </label>
   <input type="checkbox" name="[% f.html_name %]" id="[% f.id %]" value="1" />
   </div>

=head2 Textarea

   <div><label class="label" for="[% f.id %]">[% f.label %]: </label>
   <textarea name="[% f.html_name %]" id="[% f.id %]"
        rows="[% f.rows %]" cols="[% f.cols %]">[% f.fif %]</textarea></div>

=head2 Hidden

   <div><input type="hidden" name="[% f.html_name %]" id="[% f.id %]"
       value="[% f.fif %]" /></div>

=head2 Submit

   <div><input type="submit" name="[% f.html_name %]" id="[% f.id %]"
       value="[% f.value %]" /></div>

=head2 Radio group

   <div>
   <label class="label" for="[% f.id %]">[% f.label %]</label>
   [% FOR option IN f.options %]
     <input type="radio" value="[% option.value %]"
        name="[% f.name %]"
     [% IF option.value == f.fif %]
        checked="checked"
     [% END %]>
     [% option.label %]<br />
   [% END %]
   </div>

=cut
